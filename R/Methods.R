# Remove functions that are not necessary anymore

#########################################################################
<<<<<<< HEAD
# New generic functions
setGeneric("displayChainBASiCS", 
           function(object, ...) standardGeneric("displayChainBASiCS"))
setGeneric("displaySummaryBASiCS", 
           function(object, ...) standardGeneric("displaySummaryBASiCS"))
setGeneric("showFit", function(object, ...) standardGeneric("showFit"))

#########################################################################
=======
>>>>>>> master
# Methods for BASiCS_Chain objects

#' @name BASiCS_Chain-methods
#' @aliases updateObject,BASiCS_Chain-method
#' 
#' @title 'updateObject' method for BASiCS_Chain objects
#' 
#' @description 'updateObject' method for \code{\linkS4class{BASiCS_Chain}} objects.
#' 
#' @param object A \code{\linkS4class{BASiCS_Chain}} object.
#' 
#' @return Returns an updated \code{\linkS4class{BASiCS_Chain}} object that 
#' contains all model parameters in a single slot object (list).
#' 
#' @examples
#' 
#' # Not run
#' # New_Chain <- updateObject(Old_Chain)
#' 
#' @author Catalina A. Vallejos \email{cnvallej@@uc.cl}
#' 
#' @references 
#' 
#' Vallejos, Marioni and Richardson (2015). PLoS Computational Biology. 
#'  
#' @rdname BASiCS_Chain-methods
setMethod("updateObject", 
          signature = "BASiCS_Chain", 
          definition = function(object) 
          {
            #if (!("mu" %in% slotNames(object))){
            #  stop("Object was not created by an older version of BASiCS")
            #}
            
            New_Chain <- newBASiCS_Chain(parameters = list(mu = object@mu, 
                                                           delta = object@delta, phi = object@phi,
                                                           s = object@s, nu = object@nu, theta = object@theta))
            
            return(New_Chain)
          })

#' @name BASiCS_Chain-methods
#' @aliases show,BASiCS_Chain-method
#' 
#' @title 'show' method for BASiCS_Chain objects
#' 
#' @description 'show' method for \code{\linkS4class{BASiCS_Chain}} objects.
#' 
#' @param object A \code{\linkS4class{BASiCS_Chain}} object.
#' 
#' @return Prints a summary of the properties of \code{object}.
#' 
#' @examples
#' 
#' Data <- makeExampleBASiCS_Data()
#' Chain <- BASiCS_MCMC(Data, N = 50, Thin = 2, Burn = 2)
#' 
#' @author Catalina A. Vallejos \email{cnvallej@@uc.cl}
#' 
#' @references 
#' 
#' Vallejos, Marioni and Richardson (2015). PLoS Computational Biology. 
#'  
#' @rdname BASiCS_Chain-methods
setMethod("show", 
          signature = "BASiCS_Chain", 
          definition = function(object) 
          {
<<<<<<< HEAD
            N <- nrow(object@parameters$mu)
            q.bio <- ncol(object@parameters$delta)
            n <- ncol(object@parameters$phi)
            nBatch <- ncol(object@parameters$theta)
            cat("An object of class ", class(object), "\n", 
                " ", N, " MCMC samples.\n", sep = "")
            if (nBatch > 1) 
=======
            if(!("parameters" %in% methods::slotNames(object)))
>>>>>>> master
            {
              cat("'BASiCS_Chain' object was generated by an old version of BASiCS")
            }
            else
            {
              N <- nrow(object@parameters$mu)
              q.bio <- ncol(object@parameters$delta)
              n <- ncol(object@parameters$phi)
              nBatch <- ncol(object@parameters$theta)
              cat("An object of class ", class(object), "\n", 
                  " ", N, " MCMC samples.\n", sep = "")
              if (nBatch > 1) 
              {
                cat(" Dataset contains ", q.bio, " biological genes and ", 
                    n, " cells (", nBatch, " batches). \n", sep = "")
              } 
              else 
              {
                cat(" Dataset contains ", q.bio, " biological genes and ", 
                    n, " cells (1 batch). \n", sep = "")
              }
              ChainVersion <- object@.__classVersion__$BASiCS_Chain
              ChainVersion <- paste0(ChainVersion[1], ".",
                                     ChainVersion[2], ".",
                                     ChainVersion[3])
              cat(" Object stored using BASiCS version: ", ChainVersion, "\n",
                  "Parameters: ", names(object@parameters), "\n")              
            }
          })

#' @name BASiCS_Chain-methods
#' @aliases updateObject,BASiCS_Chain-method
#' 
#' @title 'updateObject' method for BASiCS_Chain objects
#' 
#' @description 'updateObject' method for \code{\linkS4class{BASiCS_Chain}} 
#' objects. It is used to convert outdated \code{\linkS4class{BASiCS_Chain}}
#' objects into a version that is compatible with the Bioconductor release
#' of BASiCS. Do not use this method is \code{\linkS4class{BASiCS_Chain}} 
#' already contains a \code{parameters} slot. 
#' 
#' @param ... Additional arguments of \code{\link[BiocGenerics]{updateObject}}
#' generic method. Not used within BASiCS. 
#' @param verbose Additional argument of \code{\link[BiocGenerics]{updateObject}}
#' generic method. Not used within BASiCS. 
#' 
#' @return Returns an updated \code{\linkS4class{BASiCS_Chain}} object that 
#' contains all model parameters in a single slot object (list).
#' 
#' @examples
#' 
#' # Not run
#' # New_Chain <- updateObject(Old_Chain)
#' 
#' @author Catalina A. Vallejos \email{cnvallej@@uc.cl}
#' 
#' @references 
#' 
#' Vallejos, Marioni and Richardson (2015). PLoS Computational Biology. 
#'  
#' @rdname BASiCS_Chain-methods
setMethod("updateObject", 
          signature = "BASiCS_Chain", 
          definition = function(object, ..., verbose = FALSE) 
          {
            if(is.null(object@mu))
            {
              stop("Object was not created by an older version of BASiCS. \n")
            }
            
            New_Chain <- newBASiCS_Chain(parameters = list(mu = object@mu, 
                                          delta = object@delta, phi = object@phi,
                                          s = object@s, nu = object@nu, 
                                          theta = object@theta))
            
            return(New_Chain)
          })

#' @name Summary
#' @aliases Summary Summary,BASiCS_Chain-method
#' 
#' @docType methods
#' @rdname Summary-BASiCS_Chain-method
#' 
#' @title 'Summary' method for BASiCS_Chain objects
#' 
#' @description For each of the BASiCS parameters (see Vallejos et al 2015), 
#' \code{Summary} returns the corresponding postior medians and limits of 
#' the high posterior density interval (probabilty equal to \code{prob})
#' 
#' @param x A \code{\linkS4class{BASiCS_Chain}} object.
#' @param prob \code{prob} argument for \code{\link[coda]{HPDinterval}} function. 
#' 
#' @return An object of class \code{\linkS4class{BASiCS_Summary}}. 
#' 
#' @examples 
#' 
#' help(BASiCS_MCMC)
#' 
#' @author Catalina A. Vallejos \email{cnvallej@@uc.cl}
#' 
#' @references 
#' 
#' Vallejos, Marioni and Richardson (2015). PLoS Computational Biology. 
setMethod("Summary", 
          signature = "BASiCS_Chain", 
          definition = function(x, prob = 0.95) 
          {
            Mu <- matrixStats::colMedians(x@parameters$mu)
            Delta <- matrixStats::colMedians(x@parameters$delta)
            Phi <- matrixStats::colMedians(x@parameters$phi)
            S <- matrixStats::colMedians(x@parameters$s)
            Nu <- matrixStats::colMedians(x@parameters$nu)
            Theta <- matrixStats::colMedians(x@parameters$theta)
    
            HPDMu <- coda::HPDinterval(coda::mcmc(x@parameters$mu), prob = prob)
            HPDDelta <- coda::HPDinterval(coda::mcmc(x@parameters$delta), prob = prob)
            HPDPhi <- coda::HPDinterval(coda::mcmc(x@parameters$phi), prob = prob)
            HPDS <- coda::HPDinterval(coda::mcmc(x@parameters$s), prob = prob)
            HPDNu <- coda::HPDinterval(coda::mcmc(x@parameters$nu), prob = prob)
            HPDTheta <- coda::HPDinterval(coda::mcmc(x@parameters$theta), prob = prob)
    
<<<<<<< HEAD
            if("epsilon" %in% names(x@parameters)){
              Beta <- matrixStats::colMedians(x@parameters$beta)
              Sigma2 <- matrixStats::colMedians(x@parameters$sigma2)
              Eta <- matrixStats::colMedians(x@parameters$eta)
              Lambda <- matrixStats::colMedians(x@parameters$lambda)
              Epsilon <- matrixStats::colMedians(x@parameters$epsilon)
              
              HPDBeta <- coda::HPDinterval(coda::mcmc(x@parameters$beta), prob = prob)
              HPDSigma2 <- coda::HPDinterval(coda::mcmc(x@parameters$sigma2), prob = prob)
              HPDEta <- coda::HPDinterval(coda::mcmc(x@parameters$eta), prob = prob)
              HPDLambda <- coda::HPDinterval(coda::mcmc(x@parameters$lambda), prob = prob)
              HPDEpsilon <- coda::HPDinterval(coda::mcmc(x@parameters$epsilon), prob = prob)
              
              Output <- new("BASiCS_Summary", 
                            parameters = list(mu = cbind(Mu, HPDMu), 
                                              delta = cbind(Delta, HPDDelta), 
                                              phi = cbind(Phi, HPDPhi), 
                                              s = cbind(S, HPDS), 
                                              nu = cbind(Nu, HPDNu), 
                                              theta = cbind(Theta, HPDTheta),
                                              beta = cbind(Beta, HPDBeta),
                                              sigma2 = cbind(Sigma2, HPDSigma2),
                                              eta = cbind(Eta, HPDEta),
                                              lambda = cbind(Lambda, HPDLambda),
                                              epsilon = cbind(Epsilon, HPDEpsilon))
                            )
            }
            
            Output <- new("BASiCS_Summary", parameters = list(mu = cbind(Mu, HPDMu), 
=======
            Output <- new("BASiCS_Summary", parameters = list(
                          mu = cbind(Mu, HPDMu), 
>>>>>>> master
                          delta = cbind(Delta, HPDDelta), 
                          phi = cbind(Phi, HPDPhi), 
                          s = cbind(S, HPDS), 
                          nu = cbind(Nu, HPDNu), 
<<<<<<< HEAD
                          theta = cbind(Theta, HPDTheta))
            )
=======
                          theta = cbind(Theta, HPDTheta)))
>>>>>>> master
            return(Output)
          })

#' @name plot-BASiCS_Chain-method
#' @aliases plot plot,BASiCS_Chain-method plot,BASiCS_Chain,ANY-method
#' 
#' @docType methods
#' @rdname plot-BASiCS_Chain-method
#' 
#' @title 'plot' method for BASiCS_Chain objects
#' 
#' @description 'plot' method for \code{\linkS4class{BASiCS_Chain}} objects
#' 
#' @param x A \code{\linkS4class{BASiCS_Chain}} object.
#' @param Param Name of the slot to be used for the plot. 
#' Possible values: \code{'mu'}, \code{'delta'}, 
#' \code{'phi'}, \code{'s'}, \code{'nu'} and \code{'theta'}
#' @param Gene Specifies which gene is requested. 
#' Required only if \code{Param = 'mu'} or \code{'delta'} 
#' @param Cell Specifies which cell is requested. 
#' Required only if \code{Param = 'phi', 's'} or \code{'nu'}
#' @param Batch Specifies which batch is requested. 
#' Required only if \code{Param = 'theta'}
#' @param ylab As in \code{\link[graphics]{par}}. 
#' @param xlab As in \code{\link[graphics]{par}}. 
#' @param ... Other graphical parameters (see \code{\link[graphics]{par}}).
#' 
#' @return A plot object
#' 
#' @examples
#' 
#' # See
#' help(BASiCS_MCMC)
#' 
#' @author Catalina A. Vallejos \email{cnvallej@@uc.cl}
#' 
#' @references 
#' 
#' Vallejos, Marioni and Richardson (2015). PLoS Computational Biology.
#' 
setMethod("plot", 
          signature = "BASiCS_Chain", 
          definition = function(x, 
                                Param = "mu", 
                                Gene = NULL, Cell = NULL, Batch = 1, 
                                ylab = "", xlab = "", ...) 
          {
            if (!(Param %in% c("mu", "delta", "phi", "s", "nu", "theta", "lambda", "epsilon"))) 
              stop("'Param' argument is invalid")
            if (Param %in% c("mu", "delta", "lambda", "epsilon") & is.null(Gene)) 
              stop("'Gene' value is required")
            if (Param %in% c("phi", "s", "nu") & is.null(Cell)) 
              stop("'Cell' value is required")
            if (Param %in% c("theta") & is.null(Batch)) 
              stop("'Batch' value is required")
    
            xlab <- ifelse(xlab == "", "Iteration", xlab)
    
            if (Param == "mu") 
            {
              object <- x@parameters$mu; Column <- Gene
              if (ylab == "") { ylab <- bquote(mu[.(Column)]) }
            }
            if (Param == "delta") 
            {
              object <- x@parameters$delta; Column <- Gene
              if (ylab == "") { ylab = bquote(delta[.(Column)]) }
            }
            if (Param == "phi") 
            {
              object <- x@parameters$phi; Column <- Cell
              if (ylab == "") { ylab = bquote(phi[.(Column)]) }
            }
            if (Param == "s") 
            {
              object <- x@parameters$s; Column <- Cell
              if (ylab == "") { ylab <- bquote(s[.(Column)]) }
            }
            if (Param == "nu") 
            {
              object <- x@parameters$nu; Column <- Cell
              if (ylab == "") { ylab <- bquote(nu[.(Column)]) }
            }
            if (Param == "theta") 
            {
              object <- x@parameters$theta; Column <- Batch
              if (ylab == "") { ylab <- bquote(theta[.(Column)]) }
            }
            if (Param == "lambda") 
            {
              object <- x@parameters$lambda; Column <- Gene
              if (ylab == "") { ylab <- bquote(lambda[.(Column)]) }
            }
            if (Param == "epsilon") 
            {
              object <- x@parameters$epsilon; Column <- Gene
              if (ylab == "") { ylab <- bquote(epsilon[.(Column)]) }
            }
    
            par(mfrow = c(1, 2))
            plot(object[, Column], 
                 type = "l", xlab = xlab, ylab = ylab, 
                 main = colnames(object)[Column], ...)
            stats::acf(object[, Column], main = "Autocorrelation")
          })


#' @name displayChainBASiCS-BASiCS_Chain-method
#' @aliases displayChainBASiCS displayChainBASiCS,BASiCS_Chain-method
#' 
#' @docType methods
#' @rdname displayChainBASiCS-BASiCS_Chain-method
#' 
#' @title Accessors for the slots of a BASiCS_Chain object
#' 
#' @description Accessors for the slots of a \code{\linkS4class{BASiCS_Chain}}
#' 
#' @param object an object of class \code{\linkS4class{BASiCS_Chain}}
#' @param Param Name of the slot to be used for the accessed. 
#' Possible values: \code{'mu'}, \code{'delta'}, \code{'phi'}, 
#' \code{'s'}, \code{'nu'} and \code{'theta'}.
#' 
#' @return The requested slot of a \code{\linkS4class{BASiCS_Chain}} object 
#' 
#' @examples
#' 
#' # See
#' help(BASiCS_MCMC)
#'   
#' @seealso \code{\linkS4class{BASiCS_Chain}}
#' 
#' @author Catalina A. Vallejos \email{cnvallej@@uc.cl}
#' 
#' @references 
#' 
#' Vallejos, Marioni and Richardson (2015). PLoS Computational Biology.
#' 
setMethod("displayChainBASiCS", 
          signature = "BASiCS_Chain", 
          definition = function(object, Param = "mu") 
          {
            if (!(Param %in% c("mu", "delta", "phi", "s", "nu", "theta", "beta", "sigma2", "lambda", "eta", "epsilon"))) 
              stop("'Param' argument is invalid")
    
            if (Param == "mu") { return(object@parameters$mu) }
            if (Param == "delta") { return(object@parameters$delta) }
            if (Param == "phi") { return(object@parameters$phi) }
            if (Param == "s") { return(object@parameters$s) }
            if (Param == "nu") { return(object@parameters$nu) }
            if (Param == "theta") { return(object@parameters$theta) }
<<<<<<< HEAD
            if (Param == "beta") { return(object@parameters$beta) }
            if (Param == "sigma2") { return(object@parameters$sigma2) }
            if (Param == "lambda") { return(object@parameters$lambda) }
            if (Param == "eta") { return(object@parameters$eta) }
            if (Param == "epsilon") { return(object@parameters$epsilon) }
          })

#' @name showFit-BASiCS_Chain-method
#' @aliases showFit showFit,BASiCS_Chain-method
#' 
#' @docType methods
#' @rdname showFit-BASiCS_Chain-method
#' 
#' @title Plotting the trend after Bayesian regression
#' 
#' @description Plotting the trend after Bayesian regression using a \code{\link[BASiCS]{BASiCS_Chain-class}} object
#' 
#' @param object an object of class \code{\link[BASiCS]{BASiCS_Chain-class}}
#' @param xlab As in \code{\link[graphics]{par}}. 
#' @param ylab As in \code{\link[graphics]{par}}.
#' @param pch As in \code{\link[graphics]{par}}. 
#' @param col As in \code{\link[graphics]{par}}. 
#' @param bty As in \code{\link[graphics]{par}}. 
#' @param smooth Logical to indicate wether the smoothScatter function is used to plot the scatter plot.
#' @param variance Variance used to build GRBFs for regression
#' @param ... Additional parameters for plotting.
#'  
#' @examples
#' Data = makeExampleBASiCS_Data()
#' MCMC_Output <- BASiCS_MCMC(Data, N = 50, Thin = 2, Burn = 2, Regression = TRUE)
#' showFit(MCMC_Output)
#' 
#' @author Nils Eling \email{eling@@ebi.ac.uk}
#' @author Catalina Vallejos \email{cnvallej@@uc.cl}
#' 
#' @references New reference
setMethod("showFit",
          signature = "BASiCS_Chain",
          definition = function(object,  
                                xlab = "log(mu[i])",
                                ylab = "log(delta[i])",
                                pch = 16, 
                                col = "blue",
                                bty = "n",
                                smooth = TRUE,
                                variance = 1.2,
                                ...){
            
            if(!("beta" %in% names(object@parameters))) stop("'Beta' is missing in parameters. 
                                                             Regression was not performed while running the MCMC.")
            
            
            m = log(object@parameters$mu[1,])
            grid.mu <- seq(round(min(m), digits = 2), round(max(m), digits = 2), length.out = 1000)
            
            # Create design matrix across the grid
            n = ncol(object@parameters$beta)
            range = diff(range(grid.mu))
            myu = seq(min(grid.mu), by = range/(n-3), length.out = n-2)
            h = diff(myu)*variance
            
            B <- matrix(1,length(grid.mu),n)
            B[,2] <- grid.mu
            for (j in 1:(n-2)){
              B[,j+2] = exp(-0.5*(grid.mu-myu[j])^2/(h[1]^2))
            }
            
            # Calculate yhat = X*beta
            yhat = apply(object@parameters$beta, 1, function(n){B%*%n})
            yhat.HPD <- HPDinterval(mcmc(t(yhat)), 0.95)
            
            df <- data.frame(mu = log(colMedians(object@parameters$mu)),
                             delta = log(colMedians(object@parameters$delta)),
                             included = !is.na(object@parameters$epsilon[1,]))
            
            df2 <- data.frame(mu2 = grid.mu,
                              yhat = rowMedians(yhat),
                              yhat.upper = yhat.HPD[,2],
                              yhat.lower = yhat.HPD[,1])
            if(smooth == TRUE){
              plot.out <- ggplot(df[df$included,]) + geom_hex(aes(mu, delta), bins = 100) +
                scale_fill_gradientn("", colours = colorRampPalette(c("dark blue", "yellow", "dark red"))(100), guide=FALSE) +
                geom_point(data = df[!df$included,], aes(mu, delta), colour="purple", alpha=0.3) +
                xlab("log(mu)") + ylab("log(delta)") + theme_minimal(base_size = 15) +
                geom_line(data = df2, mapping = aes(mu2, yhat), colour = "dark red") +
                geom_ribbon(data = df2, mapping = aes(x = mu2, ymin = yhat.lower, ymax = yhat.upper),
                            alpha = 0.5)
            }
            else{
              plot.out <- ggplot(df[df$included,]) + geom_point(aes(mu, delta), colour = "dark blue") +
                geom_point(data = df[!df$included,], aes(mu, delta), colour="purple", alpha=0.3) +
                xlab("log(mu)") + ylab("log(delta)") + theme_minimal(base_size = 15) +
                geom_line(data = df2, mapping = aes(mu2, yhat), colour = "dark red") + 
                geom_ribbon(data = df2, mapping = aes(x = mu2, ymin = yhat.lower, ymax = yhat.upper),
                            alpha = 0.5)
            }
            return(plot.out)
=======
>>>>>>> master
          })

#########################################################################
# Methods for BASiCS_Summary objects

#' @name BASiCS_Summary-methods
#' @aliases show,BASiCS_Summary-method
#' 
#' @title 'show' method for BASiCS_Summary objects
#' 
#' @description 'show' method for \code{\linkS4class{BASiCS_Summary}} objects.
#' 
#' @param object A \code{\linkS4class{BASiCS_Summary}} object.
#' 
#' @return Prints a summary of the properties of \code{object}.
#' 
#' @examples
#' 
#' # See
#' help(BASiCS_MCMC)
#' 
#' @author Catalina A. Vallejos \email{cnvallej@@uc.cl}
#' 
#' @references 
#' 
#' Vallejos, Marioni and Richardson (2015). PLoS Computational Biology.
#'
#' @rdname BASiCS_Summary-methods
setMethod("show", 
          signature = "BASiCS_Summary", 
          definition = function(object) 
          {
            q <- nrow(object@parameters$mu)
            q.bio <- nrow(object@parameters$delta)
            n <- nrow(object@parameters$phi)
            nBatch <- nrow(object@parameters$theta)
            cat("An object of class ", class(object), "\n",
                " Contains posterior medians and the limits of the \n", 
                " HPD interval for all BASiCS model parameters.\n")
    
            if (nBatch > 1) 
            {
              cat("  Dataset contains ", q, " genes ", 
                  "(", q.bio, " biological and ", q-q.bio, " technical) \n",
                  "  and ", n, " cells (", nBatch, " batches). \n", sep = "")
            } 
            else 
            {
              cat("  Dataset contains ", q, " genes ",
                  "(", q.bio, " biological and ", q-q.bio, " technical) \n", 
                  "  and ", n, " cells (1 batch). \n", sep = "")
            }
            ChainVersion <- object@.__classVersion__$BASiCS_Summary
            ChainVersion <- paste0(ChainVersion[1], ".",
                                   ChainVersion[2], ".",
                                   ChainVersion[3])
            cat("  Object stored using BASiCS version: ", ChainVersion, "\n",
                " Parameters: ", names(object@parameters), "\n")   
          })


#' @name plot-BASiCS_Summary-method
#' @aliases plot,BASiCS_Summary-method, plot,BASiCS_Summary,ANY-method
#' 
#' @docType methods
#' @rdname plot-BASiCS_Summary-method
#' 
#' @title 'plot' method for BASiCS_Summary objects
#' 
#' @description 'plot' method for \code{\linkS4class{BASiCS_Summary}} objects
#' 
#' @param x A \code{\linkS4class{BASiCS_Summary}} object.
#' @param Param Name of the slot to be used for the plot. 
#' Possible values: \code{'mu'}, \code{'delta'}, 
#' \code{'phi'}, \code{'s'}, \code{'nu'} and \code{'theta'}
#' @param Param2 Name of the second slot to be used for the plot. 
#' Possible values: \code{'mu'}, \code{'delta'}, 
#' \code{'phi'}, \code{'s'} and \code{'nu'} 
#' (combinations between gene-specific and 
#' cell-specific parameters are not admitted)
#' @param Genes Specifies which genes are requested. 
#' Required only if \code{Param = 'mu'} or \code{'delta'} 
#' @param Cells Specifies which cells are requested. 
#' Required only if \code{Param = 'phi', 's'} or \code{'nu'}
#' @param Batches Specifies which batches are requested. 
#' Required only if \code{Param = 'theta'}
#' @param xlab As in \code{\link[graphics]{par}}. 
#' @param ylab As in \code{\link[graphics]{par}}.
#' @param xlim As in \code{\link[graphics]{par}}.  
#' @param ylim As in \code{\link[graphics]{par}}. 
#' @param pch As in \code{\link[graphics]{par}}. 
#' @param col As in \code{\link[graphics]{par}}. 
#' @param bty As in \code{\link[graphics]{par}}. 
#' @param SmoothPlot Logical parameter. If \code{TRUE}, 
#' transparency will be added to the color of the dots. 
#' @param ... Other graphical parameters (see \code{\link[graphics]{par}}).
#' 
#' @return A plot object
#' 
#' @examples
#' 
#' # See
#' help(BASiCS_MCMC)
#' 
#' @author Catalina A. Vallejos \email{cnvallej@@uc.cl}
#' 
#' @references 
#' 
#' Vallejos, Marioni and Richardson (2015). PLoS Computational Biology.
#'
setMethod("plot", 
          signature = "BASiCS_Summary", 
          definition = function(x, Param = "mu", Param2 = NULL, 
                                Genes = NULL, Cells = NULL, Batches = NULL, 
                                xlab = "", ylab = "", xlim = "", ylim = "", 
                                pch = 16, col = "blue", bty = "n", 
                                SmoothPlot = TRUE, ...) 
          {
    
            if (!(Param %in% c("mu", "delta", "phi", "s", "nu", "theta"))) 
              stop("'Param' argument is invalid")
    
            q <- nrow(x@parameters$mu)
            q.bio <- nrow(x@parameters$delta)
            n <- nrow(x@parameters$phi)
            nBatch <- nrow(x@parameters$theta)
    
            if (is.null(Genes)) { Genes <- seq_len(q.bio) }
            if (is.null(Cells)) { Cells <- seq_len(n) }
            if (is.null(Batches)) { Batches <- seq_len(nBatch) }
    
            if (is.null(Param2)) 
            {
              if (Param == "mu") 
              {
                object <- x@parameters$mu; Columns <- Genes
                if (ylab == "") { ylab = expression(mu[i]) }
                if (xlab == "") { xlab = "Gene" }
              }
              if (Param == "delta") 
              {
                object <- x@parameters$delta; Columns <- Genes
                if (ylab == "") { ylab = expression(delta[i]) }
                if (xlab == "") { xlab = "Gene" }
              }
            if (Param == "phi") 
            {
                object <- x@parameters$phi; Columns <- Cells
                if (ylab == "") { ylab = expression(phi[j]) }
                if (xlab == "") { xlab = "Cell" }
            }
            if (Param == "s") 
            {
                object <- x@parameters$s; Columns <- Cells
                if (ylab == "") { ylab = expression(s[j]) }
                if (xlab == "") { xlab = "Cell" }
            }
            if (Param == "nu") 
            {
                object <- x@parameters$nu; Columns <- Cells
                if (ylab == "") { ylab = expression(nu[j]) }
                if (xlab == "") { xlab = "Cell" }
            }
            if (Param == "theta") 
            {
                object <- x@parameters$theta; Columns <- Batches
                if (ylab == "") { ylab = expression(theta[b]) }
                if (xlab == "") { xlab = "Batch" }
            }
        
            if (ylim == "") 
            {
              ylim = c(min(object[Columns, 2]), max(object[Columns, 3]))
            }
        
            # Point estimates
            plot(Columns, object[Columns, 1], 
                 xlab = xlab, ylab = ylab, ylim = ylim, 
                 pch = pch, col = col, bty = bty, ...)
            # Add HPD interval
            for (Column in Columns) 
            {
              BarLength = ifelse(length(Columns) <= 10, 0.1, 2/length(Columns))
              segments(x0 = Column, y0 = object[Column, 2], 
                       y1 = object[Column, 3], col = col)
              segments(x0 = Column - BarLength, y0 = object[Column, 2], 
                       x1 = Column + BarLength, col = col)
              segments(x0 = Column - BarLength, y0 = object[Column, 3], 
                       x1 = Column + BarLength, col = col)
            }
          } 
          else 
          {
            args <- list(...); ValidCombination <- FALSE
            if (SmoothPlot) 
            {
              col = grDevices::rgb(grDevices::col2rgb(col)[1], 
                                   grDevices::col2rgb(col)[2], 
                                   grDevices::col2rgb(col)[3], 
                                   50, maxColorValue = 255)
            }
        
            if (Param == "mu" & Param2 == "delta") 
            {
              ValidCombination <- TRUE; Columns <- Genes
              if (ylab == "") { ylab <- expression(delta[i]) }
              if (xlab == "") { xlab <- expression(mu[i]) }
              if (xlim == "") { xlim <- c(min(x@parameters$mu[Columns, 1]), 
                                          max(x@parameters$mu[Columns, 1])) }
              if (ylim == "") { ylim <- c(min(x@parameters$delta[Columns, 1]), 
                                          max(x@parameters$delta[Columns, 1])) }
              plot(x@parameters$mu[Columns, 1], x@parameters$delta[Columns, 1], 
                   xlab = xlab, ylab = ylab, ylim = ylim, 
                   pch = pch, col = col, bty = bty, ...)
            }
            if (Param == "delta" & Param2 == "mu") 
            {
              ValidCombination <- TRUE; Columns <- Genes
              if (ylab == "") { ylab <- expression(mu[i]) }
              if (xlab == "") { xlab <- expression(delta[i]) }
              if (ylim == "") { ylim <- c(min(x@parameters$mu[Columns, 1]), 
                                          max(x@parameters$mu[Columns, 1])) }
              if (xlim == "") { xlim <- c(min(x@parameters$delta[Columns, 1]), 
                                          max(x@parameters$delta[Columns, 1])) }
              plot(x@parameters$delta[Columns, 1], x@parameters$mu[Columns, 1], 
                   xlab = xlab, ylab = ylab, ylim = ylim, 
                   pch = pch, col = col, bty = bty, ...)
            }
            if (Param == "phi" & Param2 == "s") 
            {
              ValidCombination <- TRUE; Columns <- Cells
              if (ylab == "") { ylab <- expression(s[j]) }
              if (xlab == "") { xlab <- expression(phi[j]) }
              if (xlim == "") { xlim <- c(min(x@parameters$phi[Columns, 1]), 
                                          max(x@parameters$phi[Columns, 1])) }
              if (ylim == "") { ylim <- c(min(x@parameters$s[Columns, 1]), 
                                          max(x@parameters$s[Columns, 1])) }
              plot(x@parameters$phi[Columns, 1], x@parameters$s[Columns, 1], 
                   xlab = xlab, ylab = ylab, ylim = ylim, 
                   pch = pch, col = col, bty = bty, ...)
            }
            if (Param == "s" & Param2 == "phi") 
            {
              ValidCombination <- TRUE; Columns <- Cells
              if (ylab == "") { ylab <- expression(phi[j]) }
              if (xlab == "") { xlab <- expression(s[j]) }
              if (ylim == "") { ylim <- c(min(x@parameters$phi[Columns, 1]), 
                                          max(x@parameters$phi[Columns, 1])) }
              if (xlim == "") { xlim <- c(min(x@parameters$s[Columns, 1]),
                                          max(x@parameters$s[Columns, 1])) }
              plot(x@parameters$s[Columns, 1], x@parameters$phi[Columns, 1], 
                   xlab = xlab, ylab = ylab, ylim = ylim, 
                   pch = pch, col = col, bty = bty, ...)
            }
            if (Param == "phi" & Param2 == "nu") 
            {
              ValidCombination <- TRUE; Columns <- Cells
              if (ylab == "") { ylab <- expression(nu[j]) }
              if (xlab == "") { xlab <- expression(phi[j]) }
              if (xlim == "") { xlim <- c(min(x@parameters$phi[Columns, 1]), 
                                          max(x@parameters$phi[Columns, 1])) }
              if (ylim == "") { ylim <- c(min(x@parameters$nu[Columns, 1]), 
                                          max(x@parameters$nu[Columns, 1])) }
              plot(x@parameters$phi[Columns, 1], x@parameters$nu[Columns, 1], 
                   xlab = xlab, ylab = ylab, ylim = ylim, 
                   pch = pch, col = col, bty = bty, ...)
            }
            if (Param == "nu" & Param2 == "phi") 
            {
              ValidCombination <- TRUE; Columns <- Cells
              if (ylab == "") { ylab <- expression(phi[j]) }
              if (xlab == "") { xlab <- expression(nu[j]) }
              if (ylim == "") { ylim <- c(min(x@parameters$phi[Columns, 1]), 
                                          max(x@parameters$phi[Columns, 1])) }
              if (xlim == "") { xlim <- c(min(x@parameters$nu[Columns, 1]), 
                                          max(x@parameters$nu[Columns, 1])) }
              plot(x@parameters$nu[Columns, 1], x@parameters$phi[Columns, 1], 
                   xlab = xlab, ylab = ylab, ylim = ylim, 
                   pch = pch, col = col, bty = bty, ...)
            }
            if (Param == "s" & Param2 == "nu") 
            {
              ValidCombination <- TRUE; Columns <- Cells
              if (ylab == "") { ylab <- expression(nu[j]) }
              if (xlab == "") { xlab <- expression(s[j]) }
              if (xlim == "") { xlim <- c(min(x@parameters$s[Columns, 1]), 
                                          max(x@parameters$s[Columns, 1])) }
              if (ylim == "") { ylim <- c(min(x@parameters$nu[Columns, 1]), 
                                          max(x@parameters$nu[Columns, 1])) }
              plot(x@parameters$s[Columns, 1], x@parameters$nu[Columns, 1], 
                   xlab = xlab, ylab = ylab, ylim = ylim, 
                   pch = pch, col = col, bty = bty, ...)
            }
            if (Param == "nu" & Param2 == "s") 
            {
              ValidCombination <- TRUE; Columns <- Cells
              if (ylab == "") { ylab <- expression(s[j]) }
              if (xlab == "") { xlab <- expression(nu[j]) }
              if (ylim == "") { ylim <- c(min(x@parameters$s[Columns, 1]), 
                                          max(x@parameters$s[Columns, 1])) }
              if (xlim == "") { xlim <- c(min(x@parameters$nu[Columns, 1]), 
                                          max(x@parameters$nu[Columns, 1])) }
              plot(x@parameters$nu[Columns, 1], x@parameters$s[Columns, 1], 
                   xlab = xlab, ylab = ylab, ylim = ylim, 
                   pch = pch, col = col, bty = bty, ...)
            }
            if (ValidCombination == FALSE) 
            {
              stop("Invalid combination for Param and Param2. \n")
            }
          }
        })


#' @name displaySummaryBASiCS-BASiCS_Summary-method
#' @aliases displaySummaryBASiCS displaySummaryBASiCS,BASiCS_Summary-method
#' 
#' @docType methods
#' @rdname displaySummaryBASiCS-BASiCS_Summary-method
#' 
#' @title Accessors for the slots of a \code{\linkS4class{BASiCS_Summary}} object
#' 
#' @description Accessors for the slots of a \code{\linkS4class{BASiCS_Summary}}
#' object
#' 
#' @param object an object of class \code{\linkS4class{BASiCS_Summary}}
#' @param Param Name of the slot to be used for the accessed. 
#' Possible values: \code{'mu'}, \code{'delta'}, \code{'phi'}, 
#' \code{'s'}, \code{'nu'} and \code{'theta'}
#'  
#' @return The requested slot of a \code{\linkS4class{BASiCS_Summary}} object
#' 
#' @examples
#' 
#' # See
#' help(BASiCS_MCMC)
#'   
#' @seealso \code{\linkS4class{BASiCS_Summary}}
#' 
#' @author Catalina A. Vallejos \email{cnvallej@@uc.cl}
#' 
#' @references 
#' 
#' Vallejos, Marioni and Richardson (2015). PLoS Computational Biology.
#' 
setMethod("displaySummaryBASiCS", 
          signature = "BASiCS_Summary", 
          definition = function(object, Param = "mu") 
          {
            if (!(Param %in% c("mu", "delta", "phi", "s", "nu", "theta"))) 
              stop("'Param' argument is invalid")
    
            if (Param == "mu") { return(object@parameters$mu) }
            if (Param == "delta") { return(object@parameters$delta) }
            if (Param == "phi") { return(object@parameters$phi) }
            if (Param == "s") { return(object@parameters$s) }
            if (Param == "nu") { return(object@parameters$nu) }
            if (Param == "theta") { return(object@parameters$theta) }
<<<<<<< HEAD
            if (Param == "beta") { return(object@parameters$beta) }
            if (Param == "sigma2") { return(object@parameters$sigma2) }
            if (Param == "lambda") { return(object@parameters$lambda) }
            if (Param == "epsilon") { return(object@parameters$epsilon) }
=======
>>>>>>> master
          })
