#' @title Simulates expression counts according to the model implemented in BASiCS 
#' 
#' @description \code{BASiCS_Sim} creates a simulated dataset from the model implemented in BASiCS. 
#' This function is used in order to illustrate the performance of the \code{BASiCS} library.
#' 
#' @param mu Gene-specific expression levels \eqn{\mu[i]}, defined as true input molecules in case of technical genes 
#' (vector of length \code{q}, technical genes located at the end of the vector, all elements must be positive numbers)
#' @param delta Gene-specific biological cell-to-cell heterogeneity hyper-parameters \eqn{\delta[i]}, biological genes only 
#' (vector of length \code{q.bio}, all elements must be positive numbers)
#' @param phi Cell-specific mRNA content normalising constants \eqn{\phi[j]}
#' (vector of length \code{n}, all elements must be positive numbers and the sum of its elements must be equal to \code{n})
#' @param s Cell-specific capture efficiency (or amplification biases if not using UMI based counts) normalising constants \eqn{s[j]}
#' (vector of length \code{n}, all elements must be positive numbers)
#' @param theta Technical variability hyper-parameter \eqn{\theta} (must be positive)
#' 
#' @return \code{BASiCS_Sim} returns an object of class \code{\link[BASiCS]{BASiCS_Data-class}}.
#'  
#' @examples
#' 
#' data(ParamMouseShort)
#' attach(ParamMouseShort)
#' Data = BASiCS_Sim(MuShort, DeltaShort, PhiShort, SShort, ThetaShort)
#' head(counts(Data))
#' dim(counts(Data, type="biological"))
#' dim(counts(Data, type="technical"))
#' displayTechIndicator(Data)
#' displaySpikeInput(Data)
#' detach(ParamMouseShort)
#' 
#' @author Catalina A. Vallejos \email{catalina.vallejos@@mrc-bsu.cam.ac.uk}
#' 
#' @references Vallejos, Marioni and Richardson (2015). Bayesian Analysis of Single-Cell Sequencing data.
BASiCS_Sim<-function(
  mu, 
  delta, 
  phi, 
  s, 
  theta) 
{
  # Number of cells 
  n = length(phi)
  # Total number of genes, including biological and technical ones
  q = length(mu)
  # Number of biological genes
  q.bio = length(delta)
  
  # Arguments checking
  if(!(is.vector(mu) & is.numeric(mu) & all(mu>0))) stop("Invalid argument value for 'mu'.")
  if(!(is.vector(delta) & is.numeric(delta) & all(delta>=0))) stop("Invalid argument value for 'delta'.")
  if(!(is.vector(phi) & is.numeric(phi) & all(phi>0) & sum(phi)==n)) stop("Invalid argument value for 'phi'.")
  if(!(is.vector(s) & is.numeric(s) & all(s>0) & length(s)==n)) stop("Invalid argument value for 's'.")
  if(!(is.numeric(theta) & length(theta)==1 & theta>=0)) stop("Invalid argument value for 'theta'.")
   
  if(!all(c(n,q,q.bio,q-q.bio)>0)) stop("Arguments' dimensions are not compatible")
  
  # Matrix where simulated counts will be stored
  Counts.sim<-matrix(0,ncol=n,nrow=q)
  # Matrix where gene-cell specific simulated random effects will be stored 
  rho<-matrix(1,ncol=n,nrow=q.bio)
  # Simulated cell-specific random effects
  if(theta>0) {nu<-rgamma(n,shape=1/theta,rate=1/(s*theta))}
  else {nu<-s}
  # Simulated counts data
  for(i in 1:q)
  {
    # Biological genes
    if(i<=q.bio)
    {
      if(delta[i]>0){rho[i,]<-rgamma(n,shape=1/delta[i],rate=1/delta[i])}
      Counts.sim[i,]<-rpois(n,lambda=phi*nu*rho[i,]*mu[i])
    }
    # Technical genes
    else {Counts.sim[i,]<-rpois(n,lambda=nu*mu[i])}
  }  

  Data <- new("BASiCS_Data", Counts = Counts.sim, Tech=ifelse(1:q > q.bio, T, F), SpikeInput=mu[(q.bio+1):q])

  return(Data)
}

#' @title Create a simple example of a BASiCS_Data object with random data
#' 
#' @description A simple \code{\link[BASiCS]{BASiCS_Data-class}} object is generated by simulating a dataset from the
#' model in BASiCS (Vallejos et al 2015). This is used for the examples in the paper.
#' 
#' @return The simulated dataset contains 100 biological genes and 46 spike-in genes, in 41 cells. 
#' 
#' @examples 
#' Data = makeExampleBASiCS_Data()
#' is(Data, "BASiCS_Data")
#' 
#' @author Catalina A. Vallejos \email{catalina.vallejos@@mrc-bsu.cam.ac.uk}
#' 
#' @references Vallejos, Marioni and Richardson (2015). Bayesian Analysis of Single-Cell Sequencing data.  
makeExampleBASiCS_Data <- function()
{
  data(ParamMouseShort, envir = environment(), package = "BASiCS")
  InputPar = get("ParamMouseShort", envir = environment())
  Data = BASiCS_Sim(InputPar$MuShort, InputPar$DeltaShort, InputPar$PhiShort, 
                    InputPar$SShort, InputPar$ThetaShort)
  
  return(Data)  
}
  
#' @title Starting values for BASiCS_MCMC
#' 
#' @description Auxiliary function that creates starting values for \code{\link[BASiCS]{BASiCS_MCMC}}. 
#' 
#' @details Typically, this function will not be directly called. It is internally used by \code{\link[BASiCS]{BASiCS_MCMC}}.
#' 
#' @param Data A \code{\link[BASiCS]{BASiCS_Data-class}} object.
#' @param ... Optional arguments (lower bounds for starting values of adaptive proposal variances, log-scale):
#' \describe{
#'  \item{\code{ls.mu0}}{Related to gene-specific expression levels \eqn{\mu[i]}.}
#'  \item{\code{ls.delta0}}{Related to gene-specific biological cell-to-cell heterogeneity hyper-parameters \eqn{\delta[i]}.}
#'  \item{\code{ls.kappa0}}{Related to cell-specific mRNA content normalising constants (logit-scale) \eqn{\kappa[j]}}
#'  \item{\code{ls.nu0}}{Related to cell-specific random effects (technical noise) \eqn{\nu[j]}.}
#'  \item{\code{ls.theta0}}{Related to technical variability hyper-parameter \eqn{\theta}.}
#' }
#' 
#' @return A list containing starting values for all model parameters and the corresponding variances of the adaptive proposals (log-scale).
#' 
#' @examples
#'
#' Data = makeExampleBASiCS_Data()
#' 
#' # Creating starting values for BASiCS_MCMC
#' MCMC_Start <- BASiCS_MCMC_Start(Data)
#' 
#' # Creating starting values for BASiCS_MCMC 
#' # With user-defined lower bounds for adaptive proposal variances of gene-specific expression rates
#' MCMC_Start2 <- BASiCS_MCMC_Start(Data, ls.mu0 = -6)
#' 
#' @author Catalina A. Vallejos \email{catalina.vallejos@@mrc-bsu.cam.ac.uk}
#' 
#' @references Vallejos, Marioni and Richardson (2015). Bayesian Analysis of Single-Cell Sequencing data.
BASiCS_MCMC_Start<-function(
  Data,
  ...)
{
  if(!is(Data,"BASiCS_Data")) stop("'Data' is not a BASiCS_Data class object.")
   
  # Number of instrinsic genes
  q.bio<-sum(Data@Tech==F)
  # Number of cells
  n <- dim(Data@Counts)[2]
  
  # Initialize phi as a vector of ones
  kappa0 = rep(0, times = n)
  # Initialize s as the empirical capture efficiency rates
  s0=colSums(Data@Counts[Data@Tech,])/sum(Data@SpikeInput); nu0=s0 
  # Initialize mu using average 'normalised counts' across cells 
  # (correcting by empirical capture efficiency rates)
  # and true input values for spike-in genes
  nCountsBio <- t( t(Data@Counts[!Data@Tech,]) / s0 )
  meansBio <- rowMeans( nCountsBio )
  mu0<-c(meansBio,Data@SpikeInput)
  
  # Random stating value for delta
  delta0=rgamma(q.bio,1,1)
  
  # Random stating value for theta (within typically observed range)
  theta0=runif(1, min = 0.2, max = 1)
  
  # If given, load default values for adaptive proposal variances
  args <- list(...)
  ls.mu0 = ifelse("ls.mu0" %in% names(args),args$ls.mu0,-4)
  ls.delta0 = ifelse("ls.delta0" %in% names(args),args$ls.delta0,-3)
  ls.kappa0 = ifelse("ls.kappa0" %in% names(args),args$ls.kappa0,-8)
  ls.nu0 = ifelse("ls.nu0" %in% names(args),args$ls.nu0,-10)
  ls.theta0 = ifelse("ls.theta0" %in% names(args),args$ls.theta0,-6)
  
  # Starting values for the proposal variances
  ls.mu0 =  pmax(2 * log (0.02 * abs(log(mu0))),ls.mu0)
  ls.delta0 =  pmax(2 * log (0.02 * abs(log(delta0))),ls.delta0)
  ls.kappa0 =  pmax(2 * log (0.02 * abs(kappa0)),ls.kappa0)
  ls.nu0 =  pmax(2 * log (0.02 * abs(log(nu0))),ls.nu0)
  ls.theta0 =  pmax(2 * log (0.02 * abs(log(theta0))),ls.theta0)
  
  return(list("mu0"=mu0,"delta0"=delta0,"kappa0"=kappa0,"s0"=s0,"nu0"=nu0,"theta0"=theta0,
              "ls.mu0"=ls.mu0,"ls.delta0"=ls.delta0,"ls.kappa0"=ls.kappa0,"ls.nu0"=ls.nu0,"ls.theta0"=ls.theta0))
}

#' @title BASiCS MCMC sampler
#' 
#' @description MCMC sampler to perform Bayesian inference for single-cell mRNA sequencing datasets using the model described in Vallejos et al (2015). 
#' 
#' @param Data A \code{\link[BASiCS]{BASiCS_Data-class}} object.
#' @param N Total number of iterations for the MCMC sampler. Use \code{N>=max(4,Thin)}, \code{N} being a multiple of \code{Thin}. 
#' @param Thin Thining period for the MCMC sampler. Use \code{Thin>=2}.
#' @param Burn Burn-in period for the MCMC sampler. Use \code{Burn>=1}, \code{Burn<N}, \code{Burn} being a multiple of \code{Thin}.
#' @param PriorParam List of 7 elements, containing the hyper-parameter values required for the adopted prior (see Vallejos et al, 2015). All elements must be positive real numbers. 
#' \describe{
#'   \item{\code{a.delta}}{Shape hyper-parameter for the Gamma(\code{a.delta},\code{b.delta}) prior that is shared by all gene-specific biological cell-to-cell heterogeneity hyper-parameters \eqn{\delta[i]}. 
#'   Default: \code{a.delta = 1}.}
#'   \item{\code{b.delta}}{Rate hyper-parameter for the Gamma(\code{a.delta},\code{b.delta}) prior that is shared by all gene-specific biological cell-to-cell heterogeneity hyper-parameters \eqn{\delta[i]}.
#'   Default: \code{b.delta = 1}.}
#'   \item{\code{s2.kappa}}{Variance hyper-parameter for the Normal(0,\code{s2.kappa}) prior that is shared by all cell-specific mRNA content normalising constants \eqn{\kappa[j]} (logit scale).
#'   Default: \code{s2.kappa = 1}.}
#'   \item{\code{a.s}}{Shape hyper-parameter for the Gamma(\code{a.s},\code{b.s}) prior that is shared by all cell-specific capture efficiency normalising constants \eqn{\s[j]}.
#'   Default: \code{a.s = 1}.}
#'   \item{\code{b.s}}{Rate hyper-parameter for the Gamma(\code{a.s},\code{b.s}) prior that is shared by all cell-specific capture efficiency normalising constants \eqn{\s[j]}.
#'   Default: \code{b.s = 1}.}
#'   \item{\code{a.theta}}{Shape hyper-parameter for the Gamma(\code{a.theta},\code{b.theta}) prior for technical noise hyper-parameter \eqn{\theta}.
#'   Default: \code{a.theta = 1}.}
#'   \item{\code{b.theta}}{Rate hyper-parameter for the Gamma(\code{a.theta},\code{b.theta}) prior for technical noise hyper-parameter \eqn{\theta}.
#'   Default: \code{b.theta = 1}.}
#' }
#' @param AR Optimal acceptance rate for adaptive Metropolis Hastings updates. It must be a positive number between 0 and 1. Default (and recommended): \code{ar = 0.44}.
#' @param StopAdapt Iteration at which adaptive proposals are not longer adapted. Use \code{stopAdapt>=1}. Default: \code{stopAdapt = burn}.
#' @param StoreChains If \code{StoreChains = T}, MCMC chains of each parameter are stored in separate .txt files. (\code{RunName} argument used for file names). Default: \code{StoreChains = F}. 
#' @param StoreAdapt If \code{StoreAdapt = T}, trajectory of adaptive proposal variances (log scale) for each parameter 
#' are stored in separate .txt files. (\code{RunName} argument used for file names). Default: \code{StoreAdapt = F}. 
#' @param StoreDir Directory where MCMC chain will be stored (only required if \code{Store = T}). Default: \code{StoreDir = getwd()}. 
#' @param RunName Run-name to be used when storing chains and/or adaptive proposal variances in .txt files. 
#' 
#' @return An object of class \code{\link[BASiCS]{BASiCS_Chain-class}}. 
#' 
#' @examples
#' 
#' Data = makeExampleBASiCS_Data()
#' 
#' # Only a short run of the MCMC algorithm for illustration purposes
#' # Longer runs required to reach convergence
#' Result <- BASiCS_MCMC(Data, N = 100, Thin = 2, Burn = 2)
#' 
#' Summary(Result)
#' 
#' plot(Result, Param = "mu", Column = 1)
#' plot(Result, Param = "delta", Column = 1)
#' plot(Result, Param = "phi", Column = 1)
#' plot(Result, Param = "s", Column = 1)
#' plot(Result, Param = "nu", Column = 1)
#' plot(Result, Param = "theta")
#' 
#' @author Catalina A. Vallejos \email{catalina.vallejos@@mrc-bsu.cam.ac.uk}
#' 
#' @references Vallejos, Marioni and Richardson (2015). Bayesian Analysis of Single-Cell Sequencing data.
BASiCS_MCMC<- function(
  Data, 
  N, 
  Thin, 
  Burn,  
  PriorParam = list(a.delta = 1, b.delta = 1, s2.kappa = 1, a.s = 1, b.s = 1, a.theta = 1, b.theta = 1),
  AR = 0.44, 
  StopAdapt = Burn, 
  StoreChains = F, 
  StoreAdapt = F,
  StoreDir = getwd(),
  RunName="") # To be used within the .txt file names
{
  print("Start")
  
  if(!is(Data,"BASiCS_Data")) stop("'Data' is not a BASiCS_Data class object.")
  
  if(!(length(N) == 1 | length(Thin) == 1 | length(Burn) == 1)) stop("Invalid parameter values.")
  if(!(N%%Thin==0 & N>=max(4,Thin))) stop("Please use an integer value for N. It must also be a multiple of thin (N>=4)).")
  if(!(Thin%%1==0 & Thin>=2)) stop("Please use an integer value for Thin (Thin>=2).") 
  if(!(Burn%%Thin==0 & Burn<N & Burn>=1)) stop("Please use an integer value for Burn. It must also be lower than N and a multiple of thin (Burn>=1).")
   
  if(!(PriorParam$a.delta>0  & length(PriorParam$a.delta) == 1 &
       PriorParam$b.delta>0  & length(PriorParam$b.delta) == 1 &
       PriorParam$s2.kappa>0 & length(PriorParam$s2.kappa) == 1 &
       PriorParam$a.s>0      & length(PriorParam$a.s) == 1 &
       PriorParam$b.s>0      & length(PriorParam$b.s) == 1 &
       PriorParam$a.theta>0  & length(PriorParam$a.theta) == 1 &
       PriorParam$b.theta>0) & length(PriorParam$b.theta) == 1) stop("Invalid prior hyper-parameter values.")
  
  if(!(AR>0 & AR<1 & length(AR) == 1)) stop("Invalid AR value. Recommended value: AR = 0.44.")
  if(!(StopAdapt>0)) stop("Invalid StopAdapt value.")
  if(!(is.logical(StoreChains) & length(StoreChains) == 1)) stop("Invalid StoreChains value.")
  if(!(is.logical(StoreAdapt) & length(StoreAdapt) == 1)) stop("Invalid StoreAdapt value.")
  if(!(file.info(StoreDir)["isdir"])) stop("Invalid StoreDir value.")
  
  # SOME QUANTITIES USED THROUGHOUT THE MCMC ALGORITHM
  q=length(Data@Tech); q.bio=length(Data@Tech[!Data@Tech]); n=dim(Data@Counts)[2]

  # SOME SUMS USED THROUGHOUT THE MCMC ALGORITHM
  sum.bycell.all<-apply(Data@Counts,1,sum)
  sum.bycell.bio<-apply(Data@Counts[1:q.bio,],1,sum)
  sum.bygene.all<-apply(Data@Counts,2,sum)
  sum.bygene.bio<-apply(Data@Counts[1:q.bio,],2,sum)
  
  # GENERATING STARTING VALUES 
  Start=BASiCS_MCMC_Start(Data)
  # Starting values for MCMC chains
  mu0=as.vector(Start$mu0); delta0=as.vector(Start$delta0)
  kappa0=as.vector(Start$kappa0); s0=as.vector(Start$s0)
  nu0=as.vector(Start$nu0); theta0=as.numeric(Start$theta0)
  # Starting values for adaptive proposal variances
  ls.mu0=as.vector(Start$ls.mu0); ls.delta0=as.vector(Start$ls.delta0)
  ls.kappa0=as.numeric(Start$ls.kappa0) 
  ls.nu0=as.vector(Start$ls.nu0); ls.theta0=as.numeric(Start$ls.theta0)
  
  StoreAdaptNumber = as.numeric(StoreAdapt)
 
  # MCMC SAMPLER (FUNCTION IMPLEMENTED IN C++)
  Time = system.time(Chain <- HiddenBASiCS_MCMCcpp(
                                          N,
                                          Thin,
                                          Burn,
                                          as.matrix(Data@Counts),
                                          mu0, delta0, kappa0, s0, nu0, theta0,
                                          PriorParam$a.delta, PriorParam$b.delta,
                                          PriorParam$s2.kappa,
                                          PriorParam$a.s, PriorParam$b.s,
                                          PriorParam$a.theta, PriorParam$b.theta,
                                          AR,
                                          ls.mu0, ls.delta0, ls.kappa0, ls.nu0, ls.theta0,
                                          sum.bycell.all, sum.bycell.bio, sum.bygene.all, sum.bygene.bio,
                                          StoreAdaptNumber,StopAdapt))
  cat("--------------------------------------------------------------------"); cat("\n")
  cat("MCMC running time"); cat("\n")
  cat("--------------------------------------------------------------------"); cat("\n")
  print(Time)
  cat("\n")
  
  Chain$phi <- as.matrix(n * exp(Chain$kappa)/apply(exp(Chain$kappa),1,sum))
  Chain$kappa <- NULL
  
  OldDir = getwd()
    
  if(StoreChains)
  {   
    setwd(StoreDir)
    
    cat("--------------------------------------------------------------------"); cat("\n")
    cat("Storing MCMC chains of model parameters as .txt files in"); cat("\n")
    cat(paste0("'",StoreDir,"' directory ... ")); cat("\n")
    cat("--------------------------------------------------------------------"); cat("\n")
    
    write.table(Chain$mu,paste0("chain_mu_",RunName,".txt"),col.names=F,row.names=F)
    write.table(Chain$delta,paste0("chain_delta_",RunName,".txt"),col.names=F,row.names=F)
    write.table(Chain$phi,paste0("chain_phi_",RunName,".txt"),col.names=F,row.names=F)
    write.table(Chain$s,paste0("chain_s_",RunName,".txt"),col.names=F,row.names=F) 
    write.table(Chain$nu,paste0("chain_nu_",RunName,".txt"),col.names=F,row.names=F)
    write.table(Chain$theta,paste0("chain_theta_",RunName,".txt"),col.names=F,row.names=F)
    
    setwd(OldDir)
  }
    
#  if(StoreAdapt)
#  {
#    setwd(StoreDir)
#    
#    cat("--------------------------------------------------------------------"); cat("\n")
#    cat("Storing trajectories of adaptive proposal variances (log-scale) as .txt files in"); cat("\n")
#    cat(paste0("'",StoreDir,"' directory ... ")); cat("\n")
#    cat("--------------------------------------------------------------------"); cat("\n")
#      
#    write.table(Chain$ls.mu,paste0("chain_ls.mu_",RunName,".txt"),col.names=F,row.names=F)
#    write.table(Chain$ls.delta,paste0("chain_ls.delta_",RunName,".txt"),col.names=F,row.names=F)      
#    write.table(Chain$ls.kappa,paste0("chain_ls.kappa_",RunName,".txt"),col.names=F,row.names=F)
#    write.table(Chain$ls.nu,paste0("chain_ls.nu_",RunName,".txt"),col.names=F,row.names=F)
#    write.table(Chain$ls.theta,paste0("chain_ls.theta_",RunName,".txt"),col.names=F,row.names=F)
#    
#    setwd(OldDir)
#  }
  

  ChainClass <- new("BASiCS_Chain", mu = Chain$mu, delta = Chain$delta, phi = Chain$phi, s = Chain$s, nu = Chain$nu, theta = Chain$theta)
  cat("--------------------------------------------------------------------"); cat("\n")
  cat("Output"); cat("\n")
  cat("--------------------------------------------------------------------"); cat("\n")
  show(ChainClass)
  
  return(ChainClass)
}
