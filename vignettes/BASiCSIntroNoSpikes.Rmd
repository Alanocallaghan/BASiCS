---
title: 'Introduction to BASiCS: Bayesian Analysis of Single-Cell Sequencing data (no spike case)'
author: "Catalina A. Vallejos"
date: '`r Sys.Date()`'
output: html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title} 
  %\VignetteEngine{knitr::rmarkdown} 
  \usepackage[utf8]{inputenc}
---

***

# Introduction 

Here, we demonstrate how to use BASiCS using a simulated dataset that does not contain spike in genes. 

>> THIS FUNCTIONALITY IS UNDER DEVELOPMENT. NOT READY TO BE USED.

***

# Installation

BASiCS can be installed directly from Github. 

```{r install, include=FALSE}
#library(devtools)
#install_github('catavallejos/BASiCS', build_vignettes = TRUE)
```

This installation might fail if some of the dependency libraries are not yet installed. If so, please run the following lines and re-install. 

```{r dependencies}
#library(devtools)
#source("http://bioconductor.org/biocLite.R")
#biocLite("BiocGenerics")
#install.packages("Rcpp")
```

After a successful installation, the BASiCS library can be loaded using[^footnoteInstall] 

```{r load_packages}
library(BASiCS)
```

[^footnoteInstall]: The warning `"No methods found in "BiocGenerics""` might appear. Please ignore. `BASiCS` imports some of the generic functions provided by `BiocGenerics` that do not have any methods attached.

# Example

##  The input dataset

For illustration purposes, the BASiCS package includes a built-in simulated dataset:

```{r ExampleData}
DataExample = makeExampleBASiCS_Data(WithSpikes = FALSE)
```

Which was generated using the following simulated parameters

```{r SimulatedParam}
Mu =  c( 8.36,  10.65,   4.88,   6.29,  21.72,  12.93,  30.19,  83.92,   3.89,   6.34,
           57.87,  12.45,   8.08,   7.31,  15.56,  15.91,  12.24,  15.96,  19.14,   4.20,
           6.75,  27.74,   8.88,  21.21,  19.89,   7.14,  11.09,   7.19,  20.64,  73.90,
           9.05,   6.13,  16.40,   6.08,  17.89,   6.98,  10.25,  14.05,   8.14,   5.67,
           6.95,  11.16,  11.83,   7.56, 159.05,  16.41,   4.58,  15.46,  10.96,  25.05,
           18.54,   8.50,   4.05,   5.37,   4.63,   4.08,   3.75,   5.02,  27.74,  10.28,
           3.91,  13.10,   8.23,   3.64,  80.77,  20.36,   3.47,  20.12,  13.29,   7.92,
           25.51, 173.01,  27.71,   4.89,  33.10,   3.42,   6.19,   4.29,   5.19,   8.36,
           10.27,   6.86,   5.72,  37.25,   3.82,  23.97,   5.80,  14.30,  29.07,   5.30,
           7.47,   8.44,   4.24,  16.15,  23.39, 120.22,   8.92,  97.15,   9.75,  10.07)
Delta = c(1.29, 0.88, 1.51, 1.49, 0.54, 0.40, 0.85, 0.27, 0.53, 1.31,
            0.26, 0.81, 0.72, 0.70, 0.96, 0.58, 1.15, 0.82, 0.25, 5.32,
            1.13, 0.31, 0.66, 0.27, 0.76, 1.39, 1.18, 1.57, 0.55, 0.17,
            1.40, 1.47, 0.57, 2.55, 0.62, 0.77, 1.47, 0.91, 1.53, 2.89,
            1.43, 0.77, 1.37, 0.57, 0.15, 0.33, 3.99, 0.47, 0.87, 0.86,
            0.97, 1.25, 2.20, 2.19, 1.26, 1.89, 1.70, 1.89, 0.69, 1.63,
            2.83, 0.29, 1.21, 2.06, 0.20, 0.34, 0.71, 0.61, 0.71, 1.20,
            0.88, 0.17, 0.25, 1.48, 0.31, 2.49, 2.75, 1.43, 2.65, 1.97,
            0.84, 0.81, 2.75, 0.53, 2.23, 0.45, 1.87, 0.74, 0.53, 0.58,
            0.94, 0.72, 2.61, 1.56, 0.37, 0.07, 0.90, 0.12, 0.76, 1.45)
Phi = c(1.09, 1.16, 1.19, 1.14, 0.87, 1.10, 0.48, 1.06, 0.94, 0.97,
          1.09, 1.16, 1.19, 1.14, 0.87, 1.10, 0.48, 1.06, 0.94, 0.97)
Theta1 = 0.5; Theta2 = 0.75;
Theta = ifelse(1:n <= 10, Theta1, Theta2)
set.seed(1000); Nu<-rgamma(n,shape=1/Theta,rate=1/(Phi*Theta))
```

## Fitting the BASiCS model

```{r MCMC}
# The required number of iterations to reach convergence varies for different datasets
Start = BASiCS:::HiddenBASiCS_MCMC_Start(Data)
Start$mu0 <- Mu
Start$delta0 <- Delta
#Start$phi0 <- Phi
Start$theta0 <- (Theta1 + Theta2)/2
MCMC_Output <- BASiCS_MCMC(Data, N = 100000, Thin = 10, Burn = 50000, PrintProgress = FALSE, Start = Start)
MCMC_Summary <- Summary(MCMC_Output)

plot(MCMC_Output, Param = "mu", Gene = 1)
plot(MCMC_Output, Param = "nu", Cell = 1)
plot(MCMC_Output, Param = "theta", Batch = 1) # Super over-estimated
plot(MCMC_Output, Param = "theta", Batch = 2) # Super over-estimated

plot(MCMC_Summary, Param = "mu", log = "y")
points(Mu, pch = 16, col = "red")
plot(MCMC_Summary, Param = "delta")
points(Delta, pch = 16, col = "red")
plot(MCMC_Summary, Param = "phi")
points(Phi, pch = 16, col = "red")
plot(MCMC_Summary, Param = "nu")
points(Nu, pch = 16, col = "red")
plot(MCMC_Summary, Param = "theta")
points(c(Theta1, Theta2), pch = 16, col = "red")
```

To assess convergence of the chain, the convergence diagnostics provided by the package `coda` can be used. Additionally, a visual inspection is provided by traceplots, for example:

```{r Traceplots, fig.width = 5}
plot(MCMC_Output, Param = "mu", Gene = 1, log = "y")
plot(MCMC_Output, Param = "delta", Gene = 1)
plot(MCMC_Output, Param = "phi", Cell = 1)
plot(MCMC_Output, Param = "s", Cell= 1)
plot(MCMC_Output, Param = "nu", Cell = 1)
plot(MCMC_Output, Param = "theta", Batch = 1)
```

## Summarizing the model fit

To summarize the results, the function `Summary` calculates posterior medians and the High Posterior Density (HPD) intervals for each model parameter. As a default option, HPD intervals contain 0.95 probability. 

```{r Summary}
MCMC_Summary <- Summary(MCMC_Output)
head(displaySummaryBASiCS(MCMC_Summary, Param = "mu"))
head(displaySummaryBASiCS(MCMC_Summary, Param = "delta"))
head(displaySummaryBASiCS(MCMC_Summary, Param = "phi"))
head(displaySummaryBASiCS(MCMC_Summary, Param = "s"))
head(displaySummaryBASiCS(MCMC_Summary, Param = "nu"))
head(displaySummaryBASiCS(MCMC_Summary, Param = "theta"))
```

The following figures display posterior medians and the corresponding HPD 95% intervals for the normalising constants. The first figure, allows the assessment of cell-to-cell heterogeneity regarding to mRNA content. The second figure, displays possible evidence of cell-to-cell differeces in capture efficiency (and/or amplification biases). 
```{r Normalisation, fig.width = 5, fig.height = 4}
plot(MCMC_Summary, Param = "phi")
plot(MCMC_Summary, Param = "s")
```

It is also possible to generate similar plots for other model parameters
```{r OtherHPD, fig.width = 5, fig.height = 4}
plot(MCMC_Summary, Param = "mu", main = "All genes")
plot(MCMC_Summary, Param = "mu", Genes = 1:10, main = "First 10 genes")
plot(MCMC_Summary, Param = "delta", main = "All genes")
plot(MCMC_Summary, Param = "delta", Genes = c(2,5,10,50,100), main = "5 customized genes")
plot(MCMC_Summary, Param = "nu", main = "All cells")
plot(MCMC_Summary, Param = "nu", Cells = 1:5, main = "First 5 cells")
plot(MCMC_Summary, Param = "theta")
```

To contrasts posterior medians of cell-specific parameters use

```{r OtherConstrasts, fig.width = 5, fig.height = 4}
plot(MCMC_Summary, Param = "phi", Param2 = "s")
plot(MCMC_Summary, Param = "phi", Param2 = "nu")
plot(MCMC_Summary, Param = "s", Param2 = "nu")
```

To display posterior medians of $\delta_i$ (the parameters controlling the strength of the biological cell-to-cell expression heterogeneity of a gene $i$ across the population of cells under study) againts overall gene-specific expression levels $\mu_i$ use:
```{r DispVsExp, fig.width = 5, fig.height = 4}
plot(MCMC_Summary, Param = "mu", Param2 = "delta", log = "x")
```



## Highly and lowly variable genes detection

To detect highly and lowly variable genes, BASiCS employes a variance decomposition strategy based on the marginal distribution of the expression counts of gene $i$ in cell $j$ (after integrating out the random effects $\nu_j$'s and $\rho_{ij}$'s). This is given by:

$$ \mbox{Var}(X_{ij}|\mu_i,\delta_i, \phi_j, s_j, \theta) =  \phi_j^{I_i} s_j \mu_i+ \theta \left[\phi_j^{I_i} s_j \mu_i\right]^2+\mbox{I}_{i} \delta_i(\theta+1) \left[\phi_j^{I_i} s_j \mu_i\right]^2, $$

where $I_i = 1$ if $1 \leq i \leq q_0$ and $I_{i}=0$ otherwise. As $\mbox{E}(X_{ij}|\mu_i,\delta_i, \phi_j, s_j, \theta) = \phi_j^{I_i} s_j \mu_i$, the first term in the variance decomposition above is the baseline variance or *shot noise* --- based on a Poisson($\phi_j^{I_i} s_j \mu_i$) model. The second component represents the variance inflation due to unexplained technical variability and the final term is linked to biological cell-to-cell heterogeneity. 

The following code return the fraction of total variability related to each of these three components. This produces a natural ranking of the genes in terms of biological cell-to-cell variance contributions. 
```{r VarDecomp, fig.width = 5, fig.height=4}
VarDecomp = BASiCS_VarianceDecomp(Data, MCMC_Output)
head(VarDecomp)
```

Intuitively, highly variable genes (HVG) are those for which a large fraction of the total expression variability is explained by a biological cell-to-cell heterogeneity component. Here, we characterise highly variable genes as those for which 

$$ \sigma_{i} \equiv \frac{\delta_i (\theta+1)  }{[(\phi s)^* \mu_i ]^{-1} + \theta + \delta_i   (\theta+1) } > \gamma_{_H}, \hspace{0.2cm} \mbox{where} \hspace{0.2cm} (\phi s)^* =\underset{j \in \{1,\ldots,n\}}{\mathrm{median}} \left\{ \phi_j s_j \right\},$$ 

i.e. when the proportion of the total variability of the expression counts of gene $i$ in a reference cell (derived from the variance decomposition above), replacing $\phi_j s_j$ by $(\phi s)^*$ in order to represent a *typical cell* within the analysed sample) that is explained by biological cell-to-cell heterogeneity exceeds a **variance contribution threshold** $\gamma_{_H}$. In other words, we characterise as HVG those whose biological cell-to-cell heterogeneity component explains $\gamma_{_H}\times 100\%$ of the total variability (in a typical cell). Similarly, lowly variable genes (LVG) will be caracterised by low values of $\sigma_i$ (below certain threshold $\gamma_{_L}$).

BASiCS quantifies the evidence in favour of a gene being highly variable in terms of the upper tail posterior probabilities (associated to high biological cell-to-cell heterogeneity components) and labels as HVG those genes such that (for a given **evidence threshold** $\alpha_{_H}$)  

$$\pi^H_{ i  } (\gamma_{_H})= \mbox{P} \left(\sigma_{i} > \gamma_{_H} | \{x_{ij}: i=1,\ldots,q, j=1,\ldots,n\} \right) > \alpha_{_H}, $$ 

i.e. when such evidence is strong. Analogously, lowly variable genes (LVG) would be those for which 

$$\pi^L_{i } (\gamma_{_L}) = \mbox{P} \left(\sigma_{i} < \gamma_{_L} | \{x_{ij}: i=1,\ldots,q, j=1,\ldots,n\} \right) > \alpha_{_L}, $$ 

for a given variance contribution threshold $\gamma_{_L}$ and an evidence threshold $\alpha_{_L}$.

The functions `BASiCS_DetectHVG` and `BASiCS_DetectLVG` can be used to detect HVG and LVG for given variance contribution thresholds $\gamma_{_H}$ and $\gamma_{_L}$. As a default option, BASiCS searches optimal evidence thresholds $\alpha_{_H}$ and $\alpha_{_L}$ such that the *expected false discovery rate* (EFDR) and *expected false negative rate* (EFNR) coincide. This optimization is not always possible (specially for highly heterogeneous datasets, containing distinct sub-populations of cells). In those cases, `BASiCS_DetectHVG` and `BASiCS_DetectLVG` choose the evidence thresholds $\alpha_{_H}$ and $\alpha_{_L}$ such that the difference between EFDR and EFNR is minimised. For example, if $\gamma_{_H}=0.90$ and $\gamma_{_L}=0.20$:

```{r DetectionDefault, fig.width = 5, fig.height=4}
DetectHVG <- BASiCS_DetectHVG(Data, MCMC_Output, VarThreshold = 0.70, Plot = TRUE, GeneNames = paste("GeneName", 1:100))
DetectLVG <- BASiCS_DetectLVG(Data, MCMC_Output, VarThreshold = 0.40, Plot = TRUE)
```

The user can also specify specific evidence thresholds $\alpha_{_H}$ and $\alpha_{_L}$. 

```{r DetectionFix, fig.width = 5, fig.height=4}
DetectHVGFixAlpha <- BASiCS_DetectHVG(Data, MCMC_Output, VarThreshold = 0.7, Plot = T, EviThreshold = 0.8)
DetectLVGFixAlpha <- BASiCS_DetectLVG(Data, MCMC_Output, VarThreshold = 0.4, Plot = T, EviThreshold = 0.8)
```

Alternatively, if the user does not know a pre-defined variance contribution threshold, *optimal* values can be defined as those for which EFDR and EFNR coincide and are equal to a pre-specified level. The functions `BASiCS_VarThresholdSearchHVG` and `BASiCS_VarThresholdSearchLVG` search of optimal evidence thresholds using a grid of variance contribution thresholds. 

```{r DetectionGrid, fig.width = 5, fig.height=4}
BASiCS_VarThresholdSearchHVG(Data, MCMC_Output, VarThresholdsGrid = seq(0.70,0.75,by=0.01))
BASiCS_VarThresholdSearchLVG(Data, MCMC_Output, VarThresholdsGrid = seq(0.40,0.45,by=0.01))
```

Finally, a graphical display for the detection of HVG and LVG is:

```{r DetectionPlots, fig.width = 5, fig.height=4}
plot(MCMC_Summary, Param = "mu", Param2 = "delta", log = "x", col = 8)
#points(DetectHVG$Table[DetectHVG$Table$HVG==1,2], DetectHVG$Table[DetectHVG$Table$HVG==1,3], 
#       pch = 16, col = "red", cex = 1)
#points(DetectLVG$Table[DetectLVG$Table$LVG==1,2], DetectLVG$Table[DetectLVG$Table$LVG==1,3], 
#       pch = 16, col = "blue", cex = 1)
```

## Normalisation and removal of technical variation

After performing the analysis, the user might want to produce a matrix of normalised and denoised expression counts for which the effect of technical variation is removed. For this purpose, we implemented the function `BASiCS_DenoisedCounts`. For each gene $i$ and cell $j$ this function returns

$$ x^*_{ij} = \frac{ x_{ij} } {\hat{\phi}_j \hat{\nu}_j}, $$

where $x_{ij}$ is the observed expression count of gene $i$ in cell $j$, $\hat{\phi}_j$ denotes the posterior median of $\phi_j$ and $\hat{\nu}_j$ is the posterior median of $\nu_j$.

```{r DenoisedCounts}
DenoisedCounts = BASiCS_DenoisedCounts(Data = Data, Chain = MCMC_Output)
```

Alternativelly, the user can compute the normalised and denoised expression rates underlying the expression of all genes across cells using `BASiCS_DenoisedRates`. The output of this function is given by 

$$ \Lambda_{ij} = \hat{\mu_i} \hat{\rho}_{ij},  $$

where $\hat{\mu_i}$ represents the posterior median of $\mu_j$ and $\hat{\rho}_{ij}$ is given by its posterior mean (Monte Carlo estimate based on the MCMC sample of all model parameters).

```{r DenoisedRates}
DenoisedRates = BASiCS_DenoisedRates(Data = Data, Chain = MCMC_Output, Propensities = TRUE)
```

### Session information
```{r SessionInfo}
sessionInfo()
```
