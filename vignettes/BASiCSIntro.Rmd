---
title: 'Introduction to BASiCS: Bayesian Analysis of Single-Cell Sequencing data'
author: "Catalina A. Vallejos"
date: '`r Sys.Date()`'
output: html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title} 
  %\VignetteEngine{knitr::rmarkdown} 
  \usepackage[utf8]{inputenc}
---

***

# Introduction 

Single-cell mRNA sequencing can uncover novel cell-to-cell heterogeneity in gene expression levels in seemingly homogeneous populations of cells. However, these experiments are prone to high levels of unexplained technical noise, creating new challenges for identifying genes that show genuine heterogeneous expression within the population of cells under study. **BASiCS** (Bayesian Analysis of Single-Cell Sequencing data) is an integrated Bayesian hierarchical model where: 

1. Cell-specific normalization constants are estimated as part of the model parameters, 

2. Technical variability is quantified based on spike-in genes that are artificially introduced to each analysed cells lysate and 

3. The total variability of the expression counts is decomposed into technical and biological components. 

BASiCS also provides an intuitive detection criterion for highly (or lowly) variable genes within the population of cells under study. This is formalized by means of tail posterior probabilities associated to high (or low) biological cell-to-cell variance contributions, quantities that can be easily interpreted by applied users. 

Here, we demonstrate how to use BASiCS using a simulated dataset. 



***

# The BASiCS model

Throughout, we analyse the expression counts of $q$ genes, where $q_0$ are expressed in the population of cells under study (biological genes) and the remaining $q-q_0$ are spike-in (technical) genes. Let $X_{ij}$ be a random variable representing the expression count of a gene $i$ in cell $j$  ($i=1,\ldots,q$; $j=1,\ldots,n$). BASiCS is based on the following hierarchical model:
$$X_{ij}  \big| \mu_i, \phi_j, \nu_j, \rho_{ij} \sim \left\{ \begin{array}{ll} \mbox{Poisson}(\phi_j \nu_j \mu_i \rho_{ij}), \mbox{  for }i=1,\ldots,q_0, j=1,\ldots,n \\ \mbox{Poisson}(\nu_j \mu_i), \mbox{  for }i=q_0+1,\ldots,q, j=1,\ldots,n, \end{array} \right.$$

where $\nu_j$ and $\rho_{ij}$ are mutually independent random effects such that $\nu_j|s_j,\theta \sim \mbox{Gamma}(1/\theta,1/ (s_j \theta))$ and $\rho_{ij} | \delta_i \sim \mbox{Gamma} (1/\delta_i,1/\delta_i)$[^footnoteGamma]. In the previous equation, the model parameters can be interpreted as:

* $\mu_i$: normalized expression rate of a gene $i$ in the population of cells under study. In case of the spike-in technical genes, $\mu_i$ is assumed to be known (and equal to the input number of molecules of the corresponding spike-in gene).

* $\rho_{ij}$: random effects related to biological cell-to-cell expression heterogeneity of a gene $i$ across the population of cells under study. 

* $\delta_i$: variance of $\rho_{ij}$, controlling the strength of the biological cell-to-cell expression heterogeneity of a gene $i$ across the population of cells under study. 

* $\phi_j$: cell-specific normalizing constants related to differences in mRNA content. For identifiability reasons, we impose the constrain: $\sum_{j=1}^n \phi_j = n$. 

* $s_j$: cell-specific normalizing constants related to differences in capture efficiency (when analyzing UMI based expression counts) and other amplification biases such as sequencing depth (when analyzing non-UMI based expression counts, as generated by standard scRNA-seq experiments).

* $\nu_j$: random effects related to cell-to-cell technical variability. These parameters oscilate around the normalizing constants $s_j$.

* $\theta$: variance of $\nu_j$, controlling the strenght of cell-to-cell technical variability. 

[^footnoteGamma]: We parametrize the Gamma distribution such that if $X \sim \mbox{Gamma}(a,b)$, then $\mbox{E}(X)=a/b$ and $\mbox{var}(X)=a/b^2$.

A graphical representation of the BASiCS model is displayed below, based on the expression counts of 2 genes ($i$: biological and $i'$: technical) at 2 cells ($j$ and $j'$). Squared and circular nodes denote known observed quantities (observed expression counts and added number of spike-in mRNA molecules) and unknown elements, respectively. Whereas black circular nodes represent the random effects that play an intermediate role in our hierarchical structure, red circular nodes relate to unknown model parameters in the top layer of hierarchy in our model. Blue, green and grey areas highlight elements that are shared within a biological gene, technical gene or cell, respectively. BASiCS treats cell-specific normalising constants ($\phi_j$'s and $s_j$'s) as model parameters, and estimates them by combining information across all genes.  Unexplained technical noise is quantified via a single hyper-parameter $\theta$, borrowing information across all genes and cells. Finally, BASiCS quantifies biological cell-to-cell variability via gene-specific hyper-parameters $\delta_i$, borrowing information across all cells.

<!-- ![image](./BASiCS_DAG.jpg) -->
<img src="./BASiCS_DAG.jpg" height="400px" width="600px" />
\centerline{\includegraphics[height=4in]{./BASiCS_DAG.jpg}}

***

# Installation

BASiCS can be installed directly from Github. 

```{r install, include=FALSE}
#library(devtools)
#install_github('catavallejos/BASiCS', build_vignettes = TRUE)
```

This installation might fail if some of the dependency libraries are not yet installed. If so, please run the following lines and re-install. 

```{r dependencies}
#library(devtools)
#source("http://bioconductor.org/biocLite.R")
#biocLite("BiocGenerics")
#install.packages("Rcpp")
```

After a successful installation, the BASiCS library can be loaded using[^footnoteInstall] 

```{r load_packages}
library(BASiCS)
```

[^footnoteInstall]: The warning `"No methods found in "BiocGenerics""` might appear. Please ignore. `BASiCS` imports some of the generic functions provided by `BiocGenerics` that do not have any methods attached.

# Using BASiCS

##  The input dataset

The input dataset for BASiCS must contain the following 3 elements:

* `Counts`: a matrix of raw expression counts with dimensions $q$ times $n$. First $q_0$ rows must correspond to biological genes. Last $q-q_0$ rows must correspond to technical spike-in genes. Gene names must be stored as `rownames(Counts)`.

* `Tech`: a vector of `TRUE`/`FALSE` elements with length $q$. If `Tech[i] = FALSE` the gene `i` is biological; otherwise the gene is spike-in.

* `SpikeInfo`: a `data.frame` with $q-q_0$ rows. First column must contain the names associated to the spike-in genes (as in `rownames(Counts)`). Second column must contain the input number of molecules for the spike-in genes (amount per cell).

These elements must be stored into an object of class `BASiCS_Data`. For example, the following code simulates a dataset with 10 genes (7 biological and 3 spike-in) and 5 cells. 

```{r ExampleDataTest}
set.seed(1)
Counts = Counts = matrix(rpois(50*10, 2), ncol = 10)
rownames(Counts) <- c(paste0("Gene", 1:40), paste0("Spike", 1:10))
Tech = c(rep(FALSE,40),rep(TRUE,10))
set.seed(2)
SpikeInput = rgamma(10,1,1)
SpikeInfo <- data.frame("SpikeID" = paste0("Spike", 1:10), "SpikeInput" = SpikeInput)

# No batch effect
DataExample = newBASiCS_Data(Counts, Tech, SpikeInfo)

# With batch effect
DataExample = newBASiCS_Data(Counts, Tech, SpikeInfo, BatchInfo = rep(c(1,2), each = 5)) 
```

Some datasets require filtering before performing the analysis. This is in order to remove cells and/or transcripts with very low expression counts. The function `BASiCS_Filter` performs this filtering 

```{r Filter}
Filter = BASiCS_Filter(Counts = Counts, Tech = Tech, SpikeInput = SpikeInput, 
                       MinTotalCountsPerCell = 2, MinTotalCountsPerGene = 2, 
                       MinCellsWithExpression = 2, MinAvCountsPerCellsWithExpression = 2)
SpikeInfoFilter = SpikeInfo[SpikeInfo$SpikeID %in% 
                              names(Filter$IncludeGenes)[Filter$IncludeGenes == TRUE],]
FilterData = newBASiCS_Data(Counts = Filter$Counts, Tech = Filter$Tech, 
                            SpikeInfo = SpikeInfoFilter)
```

A similar code can be used when the data contains multiple batches of cells (in this example, there are 2 batches with 5 cells each):

```{r FilterBatch}
Filter = BASiCS_Filter(Counts = Counts, Tech = Tech, 
                       SpikeInput = SpikeInput, 
                       BatchInfo = c(rep(1, times = 5), rep(2, times = 5)),
                       MinTotalCountsPerCell = 2, MinTotalCountsPerGene = 2, 
                       MinCellsWithExpression = 2, MinAvCountsPerCellsWithExpression = 2)
SpikeInfoFilter = SpikeInfo[SpikeInfo$SpikeID %in% 
                              names(Filter$IncludeGenes)[Filter$IncludeGenes == TRUE],]
FilterData = newBASiCS_Data(Counts = Filter$Counts, Tech = Filter$Tech, 
                            SpikeInfo = SpikeInfoFilter, BatchInfo = Filter$BatchInfo)
```

For illustration purposes, the BASiCS package includes a built-in simulated dataset:

```{r ExampleData}
Data = makeExampleBASiCS_Data(WithBatch = FALSE)
# Use WithBatch = TRUE for an example with batch effects
```

Once a `BASiCS_Data` object has been created, we can access its elements using the functions `counts`, `displayTechIndicator` or `displaySpikeInput`. For example: 

```{r DisplayData}
head(counts(Data))
dim(counts(Data, type="biological"))
dim(counts(Data, type="technical"))
table(displayTechIndicator(Data))
length(displaySpikeInput(Data))
```

## Fitting the BASiCS model

The BASiCS model is fitted using a Bayesian approach by means of an Adaptive Metropolis within Gibbs Sampling algorithm[^RobertsRosenthal2009]. We assume prior independence between all model parameters (except within the $\phi_j$'s, for which its total sum is constrained), using a flat *non informative* prior for the normalised expression rates $\mu_1,\ldots,\mu_{q_0}$ and proper *informative* prior distributions for all other model parameters. The adopted prior is given by

* $\pi(\mu_i) \propto \mu_i^{-1}$ for $i=1, \ldots, q_0$,

* $\delta_i \sim \mbox{Gamma}(a_{\delta},b_{\delta})$ for $i=1, \ldots, q_0$,

* $n^{-1} \phi = n^{-1} (\phi_1, \ldots, \phi_n)'  \sim \mbox{Dirichlet}(p)$ with $p = (p_1,\ldots,p_n)'$ and each $p_j>0$,

* $s_j \sim \mbox{Gamma}(a_s,b_s)$,

* $\theta \sim \mbox{Gamma}(a_{\theta},b_{\theta})$, 

for fixed hyper-parameter values $a_{\delta}, b_{\delta}$, $p, a_s, b_s, a_{\theta}$ and $b_{\theta}$[^Prior]. As a default option, the sampler assumes all these hyper-parameters are equal to 1 (in case of $p$, we use $p_1 = p_2 = \cdots = p_n = 1$). However, the user can modify this option. 

[^Prior]: The analysis of simulated and real datasets suggested that the choice of these hyper-parameters does not have major consequences in posterior inference.

[^RobertsRosenthal2009]: Roberts GO, Rosenthal JS (2009). Examples of adaptive MCMC. Journal of Computational and Graphical Statistics 18: 349-367. DOI: 10.1198/jcgs.2009.06134

The function `BASiCS_MCMC` runs the sampler. It requires 4 basic arguments:

* `Data`: an object of class `BASiCS_Data`

* `N`: the total number of iterations for the algorithm

* `Thin`: thinning period for the algorithm (i.e. the output will only store parameter draws every `Thin` iterations)

* `Burn`: burning period for the algorithm (i.e. the initial `Burn` iterations are discarded)

```{r MCMC}
# The required number of iterations to reach convergence varies for different datasets
MCMC_Output <- BASiCS_MCMC(Data, N = 40000, Thin = 10, Burn = 20000, PrintProgress = FALSE)
```

If the user wants to store the output of this sampler (recommended), additional parameters `StoreChains`, `StoreDir` and `RunName` are required. For example

```{r MCMCNotRun}
# MCMC_Output <- BASiCS_MCMC(Data, N = 40000, Thin = 10, Burn = 20000, StoreChains = T, 
#                            StoreDir = getwd(), RunName = "Test")
```

To load pre-computed MCMC chains, use[^Fread]

```{r LoadChainNotRun}
# ChainMu = as.matrix(read.table("chain_mu_Test.txt"))
# ChainDelta = as.matrix(read.table("chain_delta_Test.txt"))
# ChainPhi = as.matrix(read.table("chain_phi_Test.txt"))
# ChainS = as.matrix(read.table("chain_s_Test.txt"))
# ChainNu = as.matrix(read.table("chain_nu_Test.txt"))#
# ChainTheta = read.table("chain_theta_Test.txt")[,1]
#
# MCMC_Output <- newBASiCS_Chain(mu = ChainMu, delta = ChainDelta, phi = ChainPhi, 
#                                s = ChainS, nu = ChainNu, theta = ChainTheta)
```

[^Fread]: For large datasets and/or large number of iterations, it is recommended to use the R library `data.table` and replace `read.table` by `fread`.  

For other optional parameters see `?BASiCS_MCMC`.

To access the slots of `MCMC_Output` use:

```{r AccessChains}
dim(displayChainBASiCS(MCMC_Output, Param = "mu"))
dim(displayChainBASiCS(MCMC_Output, Param = "delta"))
dim(displayChainBASiCS(MCMC_Output, Param = "phi"))
dim(displayChainBASiCS(MCMC_Output, Param = "s"))
dim(displayChainBASiCS(MCMC_Output, Param = "nu"))
length(displayChainBASiCS(MCMC_Output, Param = "theta")) # use 'dim' instead of 'length' if more than 1 batch is being analysed
```

To assess convergence of the chain, the convergence diagnostics provided by the package `coda` can be used. Additionally, a visual inspection is provided by traceplots, for example:

```{r Traceplots, fig.width = 5}
plot(MCMC_Output, Param = "mu", Gene = 1, log = "y")
plot(MCMC_Output, Param = "delta", Gene = 1)
plot(MCMC_Output, Param = "phi", Cell = 1)
plot(MCMC_Output, Param = "s", Cell= 1)
plot(MCMC_Output, Param = "nu", Cell = 1)
plot(MCMC_Output, Param = "theta", Batch = 1)
```

## Summarizing the model fit

To summarize the results, the function `Summary` calculates posterior medians and the High Posterior Density (HPD) intervals for each model parameter. As a default option, HPD intervals contain 0.95 probability. 

```{r Summary}
MCMC_Summary <- Summary(MCMC_Output)
head(displaySummaryBASiCS(MCMC_Summary, Param = "mu"))
head(displaySummaryBASiCS(MCMC_Summary, Param = "delta"))
head(displaySummaryBASiCS(MCMC_Summary, Param = "phi"))
head(displaySummaryBASiCS(MCMC_Summary, Param = "s"))
head(displaySummaryBASiCS(MCMC_Summary, Param = "nu"))
head(displaySummaryBASiCS(MCMC_Summary, Param = "theta"))
```

The following figures display posterior medians and the corresponding HPD 95% intervals for the normalising constants. The first figure, allows the assessment of cell-to-cell heterogeneity regarding to mRNA content. The second figure, displays possible evidence of cell-to-cell differeces in capture efficiency (and/or amplification biases). 
```{r Normalisation, fig.width = 5, fig.height = 4}
plot(MCMC_Summary, Param = "phi")
plot(MCMC_Summary, Param = "s")
```

It is also possible to generate similar plots for other model parameters
```{r OtherHPD, fig.width = 5, fig.height = 4}
plot(MCMC_Summary, Param = "mu", main = "All genes")
plot(MCMC_Summary, Param = "mu", Genes = 1:10, main = "First 10 genes")
plot(MCMC_Summary, Param = "delta", main = "All genes")
plot(MCMC_Summary, Param = "delta", Genes = c(2,5,10,50,100), main = "5 customized genes")
plot(MCMC_Summary, Param = "nu", main = "All cells")
plot(MCMC_Summary, Param = "nu", Cells = 1:5, main = "First 5 cells")
plot(MCMC_Summary, Param = "theta")
```

To contrasts posterior medians of cell-specific parameters use

```{r OtherConstrasts, fig.width = 5, fig.height = 4}
plot(MCMC_Summary, Param = "phi", Param2 = "s")
plot(MCMC_Summary, Param = "phi", Param2 = "nu")
plot(MCMC_Summary, Param = "s", Param2 = "nu")
```

To display posterior medians of $\delta_i$ (the parameters controlling the strength of the biological cell-to-cell expression heterogeneity of a gene $i$ across the population of cells under study) againts overall gene-specific expression levels $\mu_i$ use:
```{r DispVsExp, fig.width = 5, fig.height = 4}
plot(MCMC_Summary, Param = "mu", Param2 = "delta", log = "x")
```



## Highly and lowly variable genes detection

To detect highly and lowly variable genes, BASiCS employes a variance decomposition strategy based on the marginal distribution of the expression counts of gene $i$ in cell $j$ (after integrating out the random effects $\nu_j$'s and $\rho_{ij}$'s). This is given by:

$$ \mbox{Var}(X_{ij}|\mu_i,\delta_i, \phi_j, s_j, \theta) =  \phi_j^{I_i} s_j \mu_i+ \theta \left[\phi_j^{I_i} s_j \mu_i\right]^2+\mbox{I}_{i} \delta_i(\theta+1) \left[\phi_j^{I_i} s_j \mu_i\right]^2, $$

where $I_i = 1$ if $1 \leq i \leq q_0$ and $I_{i}=0$ otherwise. As $\mbox{E}(X_{ij}|\mu_i,\delta_i, \phi_j, s_j, \theta) = \phi_j^{I_i} s_j \mu_i$, the first term in the variance decomposition above is the baseline variance or *shot noise* --- based on a Poisson($\phi_j^{I_i} s_j \mu_i$) model. The second component represents the variance inflation due to unexplained technical variability and the final term is linked to biological cell-to-cell heterogeneity. 

The following code return the fraction of total variability related to each of these three components. This produces a natural ranking of the genes in terms of biological cell-to-cell variance contributions. 
```{r VarDecomp, fig.width = 5, fig.height=4}
VarDecomp = BASiCS_VarianceDecomp(Data, MCMC_Output)
head(VarDecomp)
```

Intuitively, highly variable genes (HVG) are those for which a large fraction of the total expression variability is explained by a biological cell-to-cell heterogeneity component. Here, we characterise highly variable genes as those for which 

$$ \sigma_{i} \equiv \frac{\delta_i (\theta+1)  }{[(\phi s)^* \mu_i ]^{-1} + \theta + \delta_i   (\theta+1) } > \gamma_{_H}, \hspace{0.2cm} \mbox{where} \hspace{0.2cm} (\phi s)^* =\underset{j \in \{1,\ldots,n\}}{\mathrm{median}} \left\{ \phi_j s_j \right\},$$ 

i.e. when the proportion of the total variability of the expression counts of gene $i$ in a reference cell (derived from the variance decomposition above), replacing $\phi_j s_j$ by $(\phi s)^*$ in order to represent a *typical cell* within the analysed sample) that is explained by biological cell-to-cell heterogeneity exceeds a **variance contribution threshold** $\gamma_{_H}$. In other words, we characterise as HVG those whose biological cell-to-cell heterogeneity component explains $\gamma_{_H}\times 100\%$ of the total variability (in a typical cell). Similarly, lowly variable genes (LVG) will be caracterised by low values of $\sigma_i$ (below certain threshold $\gamma_{_L}$).

BASiCS quantifies the evidence in favour of a gene being highly variable in terms of the upper tail posterior probabilities (associated to high biological cell-to-cell heterogeneity components) and labels as HVG those genes such that (for a given **evidence threshold** $\alpha_{_H}$)  

$$\pi^H_{ i  } (\gamma_{_H})= \mbox{P} \left(\sigma_{i} > \gamma_{_H} | \{x_{ij}: i=1,\ldots,q, j=1,\ldots,n\} \right) > \alpha_{_H}, $$ 

i.e. when such evidence is strong. Analogously, lowly variable genes (LVG) would be those for which 

$$\pi^L_{i } (\gamma_{_L}) = \mbox{P} \left(\sigma_{i} < \gamma_{_L} | \{x_{ij}: i=1,\ldots,q, j=1,\ldots,n\} \right) > \alpha_{_L}, $$ 

for a given variance contribution threshold $\gamma_{_L}$ and an evidence threshold $\alpha_{_L}$.

The functions `BASiCS_DetectHVG` and `BASiCS_DetectLVG` can be used to detect HVG and LVG for given variance contribution thresholds $\gamma_{_H}$ and $\gamma_{_L}$. As a default option, BASiCS searches optimal evidence thresholds $\alpha_{_H}$ and $\alpha_{_L}$ such that the *expected false discovery rate* (EFDR) and *expected false negative rate* (EFNR) coincide. This optimization is not always possible (specially for highly heterogeneous datasets, containing distinct sub-populations of cells). In those cases, `BASiCS_DetectHVG` and `BASiCS_DetectLVG` choose the evidence thresholds $\alpha_{_H}$ and $\alpha_{_L}$ such that the difference between EFDR and EFNR is minimised. For example, if $\gamma_{_H}=0.90$ and $\gamma_{_L}=0.20$:

```{r DetectionDefault, fig.width = 5, fig.height=4}
DetectHVG <- BASiCS_DetectHVG(Data, MCMC_Output, VarThreshold = 0.70, Plot = TRUE, GeneNames = paste("GeneName", 1:100))
DetectLVG <- BASiCS_DetectLVG(Data, MCMC_Output, VarThreshold = 0.40, Plot = TRUE)
```

The user can also specify specific evidence thresholds $\alpha_{_H}$ and $\alpha_{_L}$. 

```{r DetectionFix, fig.width = 5, fig.height=4}
DetectHVGFixAlpha <- BASiCS_DetectHVG(Data, MCMC_Output, VarThreshold = 0.7, Plot = T, EviThreshold = 0.8)
DetectLVGFixAlpha <- BASiCS_DetectLVG(Data, MCMC_Output, VarThreshold = 0.4, Plot = T, EviThreshold = 0.8)
```

Alternatively, if the user does not know a pre-defined variance contribution threshold, *optimal* values can be defined as those for which EFDR and EFNR coincide and are equal to a pre-specified level. The functions `BASiCS_VarThresholdSearchHVG` and `BASiCS_VarThresholdSearchLVG` search of optimal evidence thresholds using a grid of variance contribution thresholds. 

```{r DetectionGrid, fig.width = 5, fig.height=4}
BASiCS_VarThresholdSearchHVG(Data, MCMC_Output, VarThresholdsGrid = seq(0.70,0.75,by=0.01))
BASiCS_VarThresholdSearchLVG(Data, MCMC_Output, VarThresholdsGrid = seq(0.40,0.45,by=0.01))
```

Finally, a graphical display for the detection of HVG and LVG is:

```{r DetectionPlots, fig.width = 5, fig.height=4}
plot(MCMC_Summary, Param = "mu", Param2 = "delta", log = "x", col = 8)
points(DetectHVG$Table[DetectHVG$Table$HVG==TRUE,3], DetectHVG$Table[DetectHVG$Table$HVG==TRUE,4], 
       pch = 16, col = "red", cex = 1)
points(DetectLVG$Table[DetectLVG$Table$LVG==TRUE,3], DetectLVG$Table[DetectLVG$Table$LVG==TRUE,4], 
       pch = 16, col = "blue", cex = 1)
```

## Normalisation and removal of technical variation

After performing the analysis, the user might want to produce a matrix of normalised and denoised expression counts for which the effect of technical variation is removed. For this purpose, we implemented the function `BASiCS_DenoisedCounts`. For each gene $i$ and cell $j$ this function returns

$$ x^*_{ij} = \frac{ x_{ij} } {\hat{\phi}_j \hat{\nu}_j}, $$

where $x_{ij}$ is the observed expression count of gene $i$ in cell $j$, $\hat{\phi}_j$ denotes the posterior median of $\phi_j$ and $\hat{\nu}_j$ is the posterior median of $\nu_j$.

```{r DenoisedCounts}
DenoisedCounts = BASiCS_DenoisedCounts(Data = Data, Chain = MCMC_Output)
```

Alternativelly, the user can compute the normalised and denoised expression rates underlying the expression of all genes across cells using `BASiCS_DenoisedRates`. The output of this function is given by 

$$ \Lambda_{ij} = \hat{\mu_i} \hat{\rho}_{ij},  $$

where $\hat{\mu_i}$ represents the posterior median of $\mu_j$ and $\hat{\rho}_{ij}$ is given by its posterior mean (Monte Carlo estimate based on the MCMC sample of all model parameters).

```{r DenoisedRates}
DenoisedRates = BASiCS_DenoisedRates(Data = Data, Chain = MCMC_Output, Propensities = TRUE)
```

### Session information
```{r SessionInfo}
sessionInfo()
```
